DESIGN <- apply(DD, 1, as.list)
DD <- do.call(rbind,lapply(DESIGN, function(x){
unlist(x)
}))
DD <- data.frame( unique( DD[,c("xi","omega","alpha")] ) )
DD$mu <- factor(with(DD, snpar(xi,omega,alpha)$mu))
DD$sigma <- factor(with(DD, snpar(xi,omega,alpha)$sigma))
DD <- subset( DD, (mu %in% PARlist$mu_vec)  & (alpha %in% PARlist$alpha_vec ) & (sigma %in% PARlist$sigma_vec))
library(sn)
library(brms)
x <- seq(-5,5, by=.01)
gData <- data.frame(x=x)
gData$z <- dskew_normal(x,xi=0,omega=1)
for (i in 1:nrow(DD)) {
k <- with(DD, paste0("mu_",mu[i],"_sigma_",sigma[i],"_alpha_",alpha[i]))
y <- dsn( gData$x, xi = DD$xi[i], omega = DD$omega[i], alpha = DD$alpha[i] )
gData <- cbind(gData,y)
colnames(gData)[ncol(gData)] <- k
}
ALL$zeta_perm_sig <- ifelse(ALL$zeta_perm_pval<=.05,TRUE,FALSE)
ALL$t_pval_sig <- ifelse(ALL$t_pval <= .05, TRUE, FALSE)
ALL$welch_pval_sig <- ifelse(ALL$welch_pval <= .05, TRUE, FALSE)
ALL$wilcox_pval_sig <- ifelse(ALL$wilcox_pval <= .05, TRUE, FALSE)
ALL$vartest_pval_sig <- ifelse(ALL$vartest_pval <= .05, TRUE, FALSE)
ALL$ks_test_pval_sig <- ifelse(ALL$ks_test_pval <= .05, TRUE, FALSE)
ALL$zeta_perm_H0_true <- with(ALL, ifelse(mu==0 & sigma == 1 & alpha == 0, TRUE, FALSE))
ALL$t_H0_true <- with(ALL, ifelse(mu==0, TRUE, FALSE))
ALL$welch_H0_true <- with(ALL, ifelse(mu==0, TRUE, FALSE))
ALL$wilcox_H0_true <- with(ALL, ifelse(mu==0 & sigma == 1 & alpha == 0, TRUE, FALSE))
ALL$vartest_H0_true <- with(ALL, ifelse(sigma == 1, TRUE, FALSE))
ALL$ks_H0_true <- with(ALL, ifelse(mu==0 & sigma == 1 & alpha == 0, TRUE, FALSE))
PW <- aggregate( zeta_perm_sig ~ n+zeta_perm_H0_true, data = ALL, FUN = mean)
PW$t_sig <- aggregate( t_pval_sig ~ n+t_H0_true, data = ALL, FUN = mean)$t_pval_sig
PW$welch_sig <- aggregate( welch_pval_sig ~ n+welch_H0_true, data = ALL, FUN = mean)$welch_pval_sig
PW$wilcox_sig <- aggregate( wilcox_pval_sig ~ n+wilcox_H0_true, data = ALL, FUN = mean)$wilcox_pval_sig
PW$vartest_sig <- aggregate( vartest_pval_sig ~ n+vartest_H0_true, data = ALL, FUN = mean)$vartest_pval_sig
PW$ks_sig <- aggregate( ks_test_pval_sig ~ n+ks_H0_true, data = ALL, FUN = mean)$ks_test_pval_sig
Y <- stack(PW[,grep("_sig",colnames(PW))])
Y$H0 <- PW$zeta_perm_H0_true
Y$n <- PW$n
library(ggplot2)
theme_set(theme_bw())
ggplot(subset(Y, H0 == TRUE),
aes(n, values, color = ind, shape = ind)) +
geom_hline(yintercept = .05, lty = 3) +
geom_line() +
geom_point() +
ggtitle(expression(paste("[A] ", H[0], " true"))) +
ylab(expression(paste("P(reject ", H[0], ")"))) +
xlab("sample size (per group)") +
scale_color_discrete(
labels = c(
expression(paste(zeta[o][v])),
expression("F"),
expression("ks"),
expression("wmw"),
expression("w"),
expression("t")
)
) +
theme(
legend.title = element_blank(),
legend.text = element_text(size = 24, face = "italic")
)
ggplot(subset(Y, H0 == TRUE),
aes(n, values, color = ind, shape = ind)) +
geom_hline(yintercept = .05, lty = 3) +
geom_line() +
geom_point() +
ggtitle(expression(paste("[A] ", H[0], " true"))) +
ylab(expression(paste("P(reject ", H[0], ")"))) +
xlab("sample size (per group)") +
scale_color_discrete(
labels = c(
expression(paste(zeta[o][v])),
expression("F"),
expression("ks"),
expression("wmw"),
expression("w"),
expression("t")
)
) +
guides(shape = "none") +
theme(
legend.title = element_blank(),
legend.text = element_text(size = 24, face = "italic")
)
ggplot(subset(Y, H0 == TRUE),
aes(n, values, color = ind, shape = ind)) +
geom_hline(yintercept = .05, lty = 3) +
geom_line() +
geom_point() +
ggtitle(expression(paste("[A] ", H[0], " true"))) +
ylab(expression(paste("P(reject ", H[0], ")"))) +
xlab("sample size (per group)") +
scale_color_discrete(
labels = c(
expression(paste(zeta[o][v])),
expression("t"),
expression("w"),
expression("wmw"),
expression("F"),
expression("ks")
)
) +
guides(shape = "none") +
theme(
legend.title = element_blank(),
legend.text = element_text(size = 24, face = "italic")
)
ggplot( subset(Y,H0==FALSE), aes(n,values,color=ind,shape=ind))  + geom_hline(yintercept = .05, lty = 3) + geom_line() + geom_point() + ggtitle(expression(paste("[B] ", H[0], " false"))) + ylab(expression(paste("P(reject ", H[0],")"))) + xlab("sample size (per group)")  +
scale_color_discrete(
labels = c(
expression(paste(zeta[o][v])),
expression("t"),
expression("w"),
expression("wmw"),
expression("F"),
expression("ks")
)
) +
guides(shape = "none") +
theme(
legend.title = element_blank(),
legend.text = element_text(size = 24, face = "italic")
)
library(knitr)
options(digits=3)
opts_chunk$set(fig.width=4, fig.height=3, fig.align='center',echo=FALSE,results="hide",comment=NA,prompt=FALSE,warning=FALSE,cache=TRUE)
library(knitr)
options(digits=3)
opts_chunk$set(fig.width=4, fig.height=3, fig.align='center',echo=FALSE,results="hide",comment=NA,prompt=FALSE,warning=FALSE,cache=TRUE)
```{r, include=FALSE}
rm(list=ls())
main <- "/Users/ambraperugini/Documents/Work/presentations/slides/Psychoco_2026/"
rm(list=ls())
main <- "/Users/ambraperugini/Documents/Work/presentations/slides/Psychoco_2026/"
datadir <- paste0(main,"data/")
# ++++++++++++++++++++++++++++++++++
betapar <- function(mx,sx,n=NULL) {
vx <- sx^2
if (vx<(mx*(1-mx))) {
pezzo <- ((mx*(1-mx))/vx)-1
a <- mx*pezzo
b <- (1-mx)*pezzo
} else {
warning("adjusted formula by using n")
a <- mx*n
b <- (1-mx)*n
}
return(list(a=a,b=b))
}
# +++++++++++++++++++++++++++
snpar <- function(xi=0,omega=1,alpha=0) {
delta <- alpha/sqrt(1+alpha^2)
mu <- xi + omega * delta * sqrt( 2/pi )
sigma2 <- omega^2 * ( 1 - (2*delta^2)/pi )
return(list(mu = mu, sigma = sqrt(sigma2)))
}
# +++++++++++++++++++++++++++
sninvpar <- function( mu=0, sigma=1, xi=NULL, omega=NULL, alpha=0 ) {
if (is.null(omega)) {
delta <- alpha/sqrt(1+alpha^2)
omega2 <- sigma^2 / ( 1 - (2*delta^2) / pi )
omega <- sqrt( omega2 )
}
if (is.null(xi)) {
delta <- alpha/sqrt(1+alpha^2)
xi <- mu - omega * delta * sqrt( 2/pi )
}
return( list( xi = xi, omega = omega, alpha = alpha ) )
}
# +++++++++ funzione colori default
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
# +++++++++++++++++++++++++++++++
#' @name min_normal_uniform
#' @description Calcola il minimo tra la densità di una normale e di una uniforme
#' @param x = x vector
#' @param normPars = parametri della normale: media e dev. standard
#' @param unifPars = parametri della uniforme: minimo e massimo
#' #' @param return.all = logical, if \code{TRUE} restituisce il data set completo delle densità delle due distribuzioni
min_normal_uniform <- function( x = NULL, normPars = c(0,1), unifPars = c(0,1), return.all = FALSE ) {
if (is.null(x)) x <- seq(-5,5,by=.1)
y1 <- dnorm(x, normPars[1], normPars[2])
y2 <- dunif(x, unifPars[1], unifPars[2])
dy <- ifelse(y1<y2, y1, y2)
gData <- data.frame( x, y1, y2, dy )
if (return.all) {
return( list( gData = gData ) )
} else {
return( dy )
}
}
# +++++++++++++++++++++++++++++++++++
#' @name min_dskew_normal
#' @description Calcola il minimo tra due densità Skew-Normal
#' @param x = x vector
#' @param xi = vector of location parameters
#' @param omega = vector of scale parameters
#' @param alpha = vector of skewness parameters
#' @param plot = logical, if \code{TRUE} produce la rappresentazione grafica delle densità
#' e dell'area di sovrapposizione
#' @param return.all = logical, if \code{TRUE} restituisce il data set completo delle
#' densità delle due distribuzioni
min_dskew_normal <- function( x = seq( -5, 5, by = .01 ), xi = c(0,0), omega = c(1,1), alpha = c(0,0),
return.all = FALSE ) {
if (length(xi)==1) xi <- rep(xi,2)
if (length(omega)==1) omega <- rep(omega,2)
if (length(alpha)==1) alpha <- rep(alpha,2)
require( sn )
y1 <- dsn( x, xi = xi[1], omega = omega[1], alpha = alpha[1] )
y2 <- dsn( x, alpha = alpha[2], xi = xi[2], omega = omega[2] )
dy <- ifelse( y1 < y2, y1, y2 )
gData <- data.frame( x, y1, y2, dy )
if (return.all) {
return( list( gData = gData ) )
} else {
return( dy )
}
}
# ++++++++++++++++++++++++++++
#' @name permTest
#' @description Esegue test di permutazione su overlapping,
#'differenza tra medie e rapporto tra varianze
#' @param xList = lista di due elementi (\code{x1} e \code{x2} )
#' @param B = numero di permutazioni da effettuare
#' @param ov.type = character, type of index. If type = "2" returns the proportion of the overlapped area between two or more densities.
#' @note Il confronto tra le medie è ad una sola coda e
#'testa l'ipotesi che le medie siano uguali vs l'ipotesi
#'che la seconda sia maggiore della prima (\code{mean(x2) > mean(x1)})
#' @return Restituisce una lista con tre elementi:
#' obs = vettore dei valori osservati di non-sovrapposizione
#'       \coed{1-eta}, differenza tra le medie (\code{mean(x2)-mean(x1)}),
#'       rapporto tra le varianze
#' perm = matrice Bx3 con i valori delle stesse statistiche ottenute
#'        via permutazione
#' pval = vettore con i tre p-values
permTest <- function( xList, B = 1000, ov.type = c("1","2")) {
require(overlapping)
ov.type <- match.arg(ov.type)
names(xList) <- c("x1","x2")
N <- unlist( lapply(xList,length) )
# observed statistics
zobs <- 1-overlap( xList, type = ov.type )$OV
dobs <- diff( unlist( lapply(xList, mean) ) )
Fobs <-  with( xList, var.test(x1,x2)$statistic )
OBS <- data.frame(zobs,dobs,Fobs)
Mobs <- matrix( OBS, nrow=B, ncol=3, byrow = TRUE )
Yperm <- t( sapply(1:B, function(b){
xperm <- sample( unlist( xList ) )
xListperm <- list( x1 = xperm[1:N[1]], x2 = xperm[(N[1]+1):(sum(N))] )
zperm <- 1 - overlap( xListperm, type = ov.type )$OV
dperm <- diff( unlist( lapply(xListperm, mean) ) )
Fperm <-  with( xListperm, var.test(x1,x2)$statistic )
out <- c(zperm,dperm,Fperm)
names(out) <- c("zperm","dperm","Fperm")
out
}) )
PVAL <- (apply( Yperm >= Mobs, 2, sum )+1)/(nrow(Yperm)+1)
L <- list(obs=OBS,perm=Yperm,pval=PVAL)
return(L)
}
# ++++++++++++++++++++++++++
#' @name numeriAPA
#' @description Toglie lo zero dagli indici inclusi nell'intervallo [0,1], secondo norme APA
numeriAPA <- function(x) {
gsub("0\\.","\\.",as.character(x))
}
## +++++++++++++++++++++++++++++++++++++++++++
#' @title Grafico correlazioni
#' @param RR = correlation matrix
#' @param U = vettore con i margini del grafico
plot_correlation <- function(RR,values=FALSE,textsize=12,legendsize=10,angle=0, corrsize=4, U=c(0,0,0,0), short.names = FALSE) {
require(ggplot2)
require(reshape2)
RR <- melt(RR)
NAME <- "Correlation"
if (short.names) {
levels(RR$Var2) <- paste0("(",1:length(levels(RR$Var2)),")")
}
GGcor <- ggplot(RR,aes(Var2,Var1,fill=value))+geom_tile()+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",midpoint =0, space = "Lab",name=NAME)+
xlab("")+ylab("")+coord_fixed()+
theme(plot.margin = unit(U, "cm"),
text=element_text(size=textsize),
axis.text.x=element_text(angle=angle),
legend.text = element_text(size = legendsize),legend.title = element_text(size = legendsize))
if (values) {
GGcor <- GGcor + geom_text(aes(Var2, Var1, label = round(value,2)), color = "black", size = corrsize )
}
print(GGcor)
}
# ++++++++++++++++++++++++++++
#' @name perm.test
#' @description Esegue test di permutazione su overlapping,
#'differenza tra medie e rapporto tra varianze
#' @param x = lista di due elementi (\code{x1} e \code{x2} )
#' @param B = numero di permutazioni da effettuare
#' @return Restituisce una lista con tre elementi:
#' obs = valore osservato di non-sovrapposizione
#'       \coed{1-eta}
#' perm = valori della stessa statistica ottenute
#'        via permutazione
#' pval = p-value
perm.test <- function (x, B = 1000,
return.distribution = FALSE, ...)
{
# control
args <- c(as.list(environment()), list(...))
pairsOverlap <- ifelse(length(x)==2, FALSE, TRUE)
N <- unlist( lapply(x,length) )
out <- overlap(x, ...)
if (pairsOverlap) {
zobs <- 1-out$OVPairs
Zperm <- t(sapply(1:B, function(b) {
xListperm <- perm.pairs( x )
ovperm <- unlist( lapply(xListperm, overlap, ...) )
zperm <- 1 - ovperm
}))
} else {
zobs <- 1-out$OV
Zperm <- t(sapply(1:B, function(b) {
xperm <- sample( unlist( x ) )
xListperm <- list( x1 = xperm[1:N[1]], x2 = xperm[(N[1]+1):(sum(N))] )
zperm <- 1 - overlap( xListperm, ... )$OV
}))
}
## (sum( zperm >= obsz ) +1) / (length( zperm )+1) LIVIO
colnames(Zperm) <- gsub("\\.OV","",colnames(Zperm))
if (nrow(Zperm) > 1) {
ZOBS <- matrix( zobs, nrow(Zperm), ncol(Zperm), byrow = TRUE )
pval <- (apply( Zperm > ZOBS, 2, sum ) + 1)/ (nrow(Zperm)+1)
} else {
pval <- (sum(Zperm > zobs)+1) / (length(Zperm)+1)
}
if (return.distribution) {
return(list(Zobs = zobs, pval = pval, Zperm = Zperm))
} else {
return(list(Zobs = zobs, pval = pval))
}
}
load(paste0(datadir,"R02_sim07.rda"))
load(paste0(datadir,"sim07.rda"))
INDICI <- colnames(ALL)[grep("pval",colnames(ALL))]
INDICI <- INDICI[!(grepl("_norm",INDICI)|grepl("F_",INDICI)|grepl("mean_",INDICI))]
LEGENDA <- data.frame( var = colnames(ALL), desc = c("media camp. 1", "sd camp. 1","media camp. 2", "sd camp. 2", "overlapping tipo 1", "overlapping tipo 2", "sample size","differenza tra le xi","skewness","varianza","vera sovrapposizione","t test","welch test","wilcoxon test", "var test", "overlapping perm","mean perm", "var perm", "shapiro camp. 1", "shapiro camp. 2","kolmogorov","media secondo campione","ds secondo campione") )
ALL <- subset(ALL, (mu %in% PARlist$mu_vec) & (alpha %in% PARlist$alpha_vec ) & (sigma %in% PARlist$sigma_vec))
ALL <- subset(ALL, (mu %in% PARlist$mu_vec) & (alpha %in% PARlist$alpha_vec ) & (sigma %in% PARlist$sigma_vec))
ALL$mu <- factor(ALL$mu)
ALL$mu <- factor(ALL$mu)
ALL$sigma <- factor(ALL$sigma)
MUSI <- with( PARlist, expand.grid(mu=mu_vec, sigma=sigma_vec, alpha = alpha_vec) )
MUSI <- with( PARlist, expand.grid(mu=mu_vec, sigma=sigma_vec, alpha = alpha_vec) )
DESIGN <- NULL
for (i in 1:nrow(MUSI)) {
DESIGN <- rbind( DESIGN, unlist( with( MUSI, sninvpar(mu[i],sigma[i],alpha = alpha[i]) )) )
}
DESIGN <- data.frame(DESIGN)
DD <- with( DESIGN, expand.grid( xi = unique(xi), omega = unique(omega),
alpha = unique(alpha), n = PARlist$n_vec ) )
DESIGN <- apply(DD, 1, as.list)
DD <- do.call(rbind,lapply(DESIGN, function(x){
unlist(x)
}))
DD <- data.frame( unique( DD[,c("xi","omega","alpha")] ) )
DD$mu <- factor(with(DD, snpar(xi,omega,alpha)$mu))
DD$sigma <- factor(with(DD, snpar(xi,omega,alpha)$sigma))
DD <- subset( DD, (mu %in% PARlist$mu_vec)  & (alpha %in% PARlist$alpha_vec ) & (sigma %in% PARlist$sigma_vec))
library(sn)
library(brms)
x <- seq(-5,5, by=.01)
gData <- data.frame(x=x)
gData$z <- dskew_normal(x,xi=0,omega=1)
for (i in 1:nrow(DD)) {
k <- with(DD, paste0("mu_",mu[i],"_sigma_",sigma[i],"_alpha_",alpha[i]))
y <- dsn( gData$x, xi = DD$xi[i], omega = DD$omega[i], alpha = DD$alpha[i] )
gData <- cbind(gData,y)
colnames(gData)[ncol(gData)] <- k
}
ALL$zeta_perm_sig <- ifelse(ALL$zeta_perm_pval<=.05,TRUE,FALSE)
ALL$t_pval_sig <- ifelse(ALL$t_pval <= .05, TRUE, FALSE)
ALL$welch_pval_sig <- ifelse(ALL$welch_pval <= .05, TRUE, FALSE)
ALL$wilcox_pval_sig <- ifelse(ALL$wilcox_pval <= .05, TRUE, FALSE)
ALL$vartest_pval_sig <- ifelse(ALL$vartest_pval <= .05, TRUE, FALSE)
ALL$ks_test_pval_sig <- ifelse(ALL$ks_test_pval <= .05, TRUE, FALSE)
ALL$zeta_perm_H0_true <- with(ALL, ifelse(mu==0 & sigma == 1 & alpha == 0, TRUE, FALSE))
ALL$welch_H0_true <- with(ALL, ifelse(mu==0, TRUE, FALSE))
ALL$wilcox_H0_true <- with(ALL, ifelse(mu==0 & sigma == 1 & alpha == 0, TRUE, FALSE))
ALL$ks_H0_true <- with(ALL, ifelse(mu==0 & sigma == 1 & alpha == 0, TRUE, FALSE))
PW$welch_sig <- aggregate( welch_pval_sig ~ n+welch_H0_true, data = ALL, FUN = mean)$welch_pval_sig
PW$welch_sig <- aggregate( welch_pval_sig ~ n+welch_H0_true, data = ALL, FUN = mean)$welch_pval_sig
PW$wilcox_sig <- aggregate( wilcox_pval_sig ~ n+wilcox_H0_true, data = ALL, FUN = mean)$wilcox_pval_sig
PW$wilcox_sig <- aggregate( wilcox_pval_sig ~ n+wilcox_H0_true, data = ALL, FUN = mean)$wilcox_pval_sig
PW$vartest_sig <- aggregate( vartest_pval_sig ~ n+vartest_H0_true, data = ALL, FUN = mean)$vartest_pval_sig
PW <- aggregate( zeta_perm_sig ~ n+zeta_perm_H0_true, data = ALL, FUN = mean)
PW$t_sig <- aggregate( t_pval_sig ~ n+t_H0_true, data = ALL, FUN = mean)$t_pval_sig
ALL$zeta_perm_sig <- ifelse(ALL$zeta_perm_pval<=.05,TRUE,FALSE)
ALL$t_pval_sig <- ifelse(ALL$t_pval <= .05, TRUE, FALSE)
ALL$welch_pval_sig <- ifelse(ALL$welch_pval <= .05, TRUE, FALSE)
ALL$wilcox_pval_sig <- ifelse(ALL$wilcox_pval <= .05, TRUE, FALSE)
ALL$vartest_pval_sig <- ifelse(ALL$vartest_pval <= .05, TRUE, FALSE)
ALL$ks_test_pval_sig <- ifelse(ALL$ks_test_pval <= .05, TRUE, FALSE)
ALL$zeta_perm_H0_true <- with(ALL, ifelse(mu==0 & sigma == 1 & alpha == 0, TRUE, FALSE))
ALL$t_H0_true <- with(ALL, ifelse(mu==0, TRUE, FALSE))
ALL$welch_H0_true <- with(ALL, ifelse(mu==0, TRUE, FALSE))
ALL$wilcox_H0_true <- with(ALL, ifelse(mu==0 & sigma == 1 & alpha == 0, TRUE, FALSE))
ALL$vartest_H0_true <- with(ALL, ifelse(sigma == 1, TRUE, FALSE))
ALL$ks_H0_true <- with(ALL, ifelse(mu==0 & sigma == 1 & alpha == 0, TRUE, FALSE))
PW <- aggregate( zeta_perm_sig ~ n+zeta_perm_H0_true, data = ALL, FUN = mean)
PW$t_sig <- aggregate( t_pval_sig ~ n+t_H0_true, data = ALL, FUN = mean)$t_pval_sig
PW$welch_sig <- aggregate( welch_pval_sig ~ n+welch_H0_true, data = ALL, FUN = mean)$welch_pval_sig
PW$wilcox_sig <- aggregate( wilcox_pval_sig ~ n+wilcox_H0_true, data = ALL, FUN = mean)$wilcox_pval_sig
PW$vartest_sig <- aggregate( vartest_pval_sig ~ n+vartest_H0_true, data = ALL, FUN = mean)$vartest_pval_sig
PW$ks_sig <- aggregate( ks_test_pval_sig ~ n+ks_H0_true, data = ALL, FUN = mean)$ks_test_pval_sig
Y <- stack(PW[,grep("_sig",colnames(PW))])
Y$H0 <- PW$zeta_perm_H0_true
Y$n <- PW$n
library(ggplot2)
theme_set(theme_bw())
ggplot(subset(Y, H0 == TRUE),
aes(n, values, color = ind, shape = ind)) +
geom_hline(yintercept = .05, lty = 3) +
geom_line(width = 5) +
geom_point() +
ggtitle(expression(paste("Type I error: ",H[0], " true"))) +
ylab(expression(paste("P(reject ", H[0], ")"))) +
xlab("sample size (per group)") +
scale_color_discrete(
labels = c(
expression(paste(zeta[o][v])),
expression("t"),
expression("w"),
expression("wmw"),
expression("F"),
expression("ks")
)
) +
guides(shape = "none") +
theme(
legend.title = element_blank(),
legend.text  = element_text(size = 24, face = "italic"),
plot.title   = element_text(size = 30, face = "bold"),
axis.title.x = element_text(size = 26),
axis.title.y = element_text(size = 26),
axis.text    = element_text(size = 15)
)
ggplot(subset(Y, H0 == TRUE),
aes(n, values, color = ind, shape = ind)) +
geom_hline(yintercept = .05, lty = 3) +
geom_line(width = 5) +
geom_point() +
ggtitle(expression(paste("Type I error: ",H[0], " true"))) +
ylab(expression(paste("P(reject ", H[0], ")"))) +
xlab("sample size (per group)") +
scale_color_discrete(
labels = c(
expression(paste(zeta[o][v])),
expression("t"),
expression("w"),
expression("wmw"),
expression("F"),
expression("ks")
)
) +
guides(shape = "none") +
theme(
legend.title = element_blank(),
legend.text  = element_text(size = 24, face = "italic"),
plot.title   = element_text(size = 30, face = "bold"),
axis.title.x = element_text(size = 26),
axis.title.y = element_text(size = 26),
axis.text    = element_text(size = 15)
)
rm(list=ls())
main <- "/Users/ambraperugini/Documents/Work/projects/Overlapping/"
# main <- "~/lavori/overpermutation/"
# if (!grepl("bayes",Sys.info()["user"])) main <- gsub("~","~/MEGAsync",main)
datadir <- paste0(main,"data/")
library(overlapping)
DATA<-read.csv("EngTurk.csv")
DATA<-read.csv(paste0(datadir,"EngTurk.csv"))
table(DATA$item[DATA$ItemType == "High_freq" & DATA$Language == "English"])
table(DATA$item[DATA$ItemType == "Low_freq" & DATA$Language == "English"])
low_frequency <-DATA$ReactionTime[DATA$item == "poor children"]
high_frequency <- DATA$ReactionTime[DATA$item == "blue eyes"]
xList <- list( x1 = low_frequency, x2 = high_frequency )
length(unlist(xList))
overlap( xList, plot = T )
TTEST <- with( xList, t.test( x1, x2, var.equal = TRUE ) )
TTEST
obsz <- 1 - overlap( xList )$OV
obsz
MX <- lapply(xList, mean)
SDX <- lapply(xList, var)
SKX <- lapply(xList, skewness)
library(datawizard)
SKX <- lapply(xList, skewness)
B <- 2e3
n <- length(xList[[1]])
zperm <- sapply( 1:B, function(x){
xperm <- sample( unlist( xList ) )
xListperm <- list( x1 = xperm[1:n], x2 = xperm[(n+1):(n*2 )] )
1 - overlap( xListperm )$OV
})
PVAL <- (sum( zperm > obsz )+1) / (length( zperm )+1)
PVAL
TTEST <- with( xList, t.test( x1, x2, var.equal = TRUE ) )
TTEST
low_frequency <-DATA$ReactionTime[DATA$item == "difficult life"]
