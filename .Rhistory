main <- getwd()
datadir <- paste0(main,"data/")
# ++++++++++++++++++++++++++++++++++
betapar <- function(mx,sx,n=NULL) {
vx <- sx^2
if (vx<(mx*(1-mx))) {
pezzo <- ((mx*(1-mx))/vx)-1
a <- mx*pezzo
b <- (1-mx)*pezzo
} else {
warning("adjusted formula by using n")
a <- mx*n
b <- (1-mx)*n
}
return(list(a=a,b=b))
}
# +++++++++++++++++++++++++++
snpar <- function(xi=0,omega=1,alpha=0) {
delta <- alpha/sqrt(1+alpha^2)
mu <- xi + omega * delta * sqrt( 2/pi )
sigma2 <- omega^2 * ( 1 - (2*delta^2)/pi )
return(list(mu = mu, sigma = sqrt(sigma2)))
}
# +++++++++++++++++++++++++++
sninvpar <- function( mu=0, sigma=1, xi=NULL, omega=NULL, alpha=0 ) {
if (is.null(omega)) {
delta <- alpha/sqrt(1+alpha^2)
omega2 <- sigma^2 / ( 1 - (2*delta^2) / pi )
omega <- sqrt( omega2 )
}
if (is.null(xi)) {
delta <- alpha/sqrt(1+alpha^2)
xi <- mu - omega * delta * sqrt( 2/pi )
}
return( list( xi = xi, omega = omega, alpha = alpha ) )
}
# +++++++++ default colour function
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
# +++++++++++++++++++++++++++++++
#' @#' @name min_normal_uniform
#' @description Computes the minimum between the density of a normal distribution and a uniform distribution.
#' @param x Numeric vector of x values.
#' @param normPars Parameters of the normal distribution: mean and standard deviation.
#' @param unifPars Parameters of the uniform distribution: minimum and maximum.
#' @param return.all Logical. If \code{TRUE}, returns the full dataset containing the densities of both distributions.
min_normal_uniform <- function( x = NULL, normPars = c(0,1), unifPars = c(0,1), return.all = FALSE ) {
if (is.null(x)) x <- seq(-5,5,by=.1)
y1 <- dnorm(x, normPars[1], normPars[2])
y2 <- dunif(x, unifPars[1], unifPars[2])
dy <- ifelse(y1<y2, y1, y2)
gData <- data.frame( x, y1, y2, dy )
if (return.all) {
return( list( gData = gData ) )
} else {
return( dy )
}
}
#' @name min_dskew_normal
#' @description #' @description Computes the minimum between two Skew-Normal density functions.
#' @param x Numeric vector of x values.
#' @param xi Vector of location parameters.
#' @param omega Vector of scale parameters.
#' @param alpha Vector of skewness parameters.
#' @param plot Logical. If \code{TRUE}, produces a graphical representation of the densities
#' and their overlapping area.
#' @param return.all Logical. If \code{TRUE}, returns the full dataset containing the
#' densities of the two distributions.
min_dskew_normal <- function( x = seq( -5, 5, by = .01 ), xi = c(0,0), omega = c(1,1), alpha = c(0,0),
return.all = FALSE ) {
if (length(xi)==1) xi <- rep(xi,2)
if (length(omega)==1) omega <- rep(omega,2)
if (length(alpha)==1) alpha <- rep(alpha,2)
require( sn )
y1 <- dsn( x, xi = xi[1], omega = omega[1], alpha = alpha[1] )
y2 <- dsn( x, alpha = alpha[2], xi = xi[2], omega = omega[2] )
dy <- ifelse( y1 < y2, y1, y2 )
gData <- data.frame( x, y1, y2, dy )
if (return.all) {
return( list( gData = gData ) )
} else {
return( dy )
}
}
# ++++++++++++++++++++++++++++
#' @name permTest
#'#' @description Performs permutation tests on the overlapping index,
#' mean difference, and variance ratio.
#' @param xList A list with two elements (\code{x1} and \code{x2}).
#' @param B Number of permutations to perform.
#' @param ov.type Character, type of index. If \code{type = "2"}, returns the proportion
#' of overlapped area between two or more densities.
#' @note The comparison between means is one-tailed and tests the hypothesis
#' of equal means against the alternative that the second mean is greater
#' than the first (\code{mean(x2) > mean(x1)}).
#' @return A list with three elements:
#' \item{obs}{Vector of observed statistics: non-overlap value
#' (\code{1 - eta}), mean difference (\code{mean(x2) - mean(x1)}),
#' and variance ratio.}
#' \item{perm}{A B x 3 matrix containing the same statistics obtained
#' through permutation.}
#' \item{pval}{Vector containing the three corresponding p-values.
permTest <- function( xList, B = 1000, ov.type = c("1","2")) {
require(overlapping)
ov.type <- match.arg(ov.type)
names(xList) <- c("x1","x2")
N <- unlist( lapply(xList,length) )
# observed statistics
zobs <- 1-overlap( xList, type = ov.type )$OV
dobs <- diff( unlist( lapply(xList, mean) ) )
Fobs <-  with( xList, var.test(x1,x2)$statistic )
OBS <- data.frame(zobs,dobs,Fobs)
Mobs <- matrix( OBS, nrow=B, ncol=3, byrow = TRUE )
Yperm <- t( sapply(1:B, function(b){
xperm <- sample( unlist( xList ) )
xListperm <- list( x1 = xperm[1:N[1]], x2 = xperm[(N[1]+1):(sum(N))] )
zperm <- 1 - overlap( xListperm, type = ov.type )$OV
dperm <- diff( unlist( lapply(xListperm, mean) ) )
Fperm <-  with( xListperm, var.test(x1,x2)$statistic )
out <- c(zperm,dperm,Fperm)
names(out) <- c("zperm","dperm","Fperm")
out
}) )
PVAL <- (apply( Yperm >= Mobs, 2, sum )+1)/(nrow(Yperm)+1)
L <- list(obs=OBS,perm=Yperm,pval=PVAL)
return(L)
}
# ++++++++++++++++++++++++++
#' @name numeriAPA
#' #' @description Removes the leading zero from values in the interval [0, 1],
#' according to APA reporting guidelines.
numeriAPA <- function(x) {
gsub("0\\.","\\.",as.character(x))
}
## +++++++++++++++++++++++++++++++++++++++++++
#' #' @title Correlation plot
#' @param RR Correlation matrix.
#' @param U Vector specifying the plot margins.
plot_correlation <- function(RR,values=FALSE,textsize=12,legendsize=10,angle=0, corrsize=4, U=c(0,0,0,0), short.names = FALSE) {
require(ggplot2)
require(reshape2)
RR <- melt(RR)
NAME <- "Correlation"
if (short.names) {
levels(RR$Var2) <- paste0("(",1:length(levels(RR$Var2)),")")
}
GGcor <- ggplot(RR,aes(Var2,Var1,fill=value))+geom_tile()+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",midpoint =0, space = "Lab",name=NAME)+
xlab("")+ylab("")+coord_fixed()+
theme(plot.margin = unit(U, "cm"),
text=element_text(size=textsize),
axis.text.x=element_text(angle=angle),
legend.text = element_text(size = legendsize),legend.title = element_text(size = legendsize))
if (values) {
GGcor <- GGcor + geom_text(aes(Var2, Var1, label = round(value,2)), color = "black", size = corrsize )
}
print(GGcor)
}
# ++++++++++++++++++++++++++++
#' @name perm.test
#' #' @description Performs a permutation test on the overlapping index.
#' @param x A list with two elements (\code{x1} and \code{x2}).
#' @param B Number of permutations to perform.
#' @return A list with three elements:
#' \item{obs}{Observed value of non-overlap (\code{1 - eta}).}
#' \item{perm}{Values of the same statistic obtained via permutation.}
#' \item{pval}Permutation-based p-value.
#'
perm.test <- function (x, B = 1000,
return.distribution = FALSE, ...)
{
# control
args <- c(as.list(environment()), list(...))
pairsOverlap <- ifelse(length(x)==2, FALSE, TRUE)
N <- unlist( lapply(x,length) )
out <- overlap(x, ...)
if (pairsOverlap) {
zobs <- 1-out$OVPairs
Zperm <- t(sapply(1:B, function(b) {
xListperm <- perm.pairs( x )
ovperm <- unlist( lapply(xListperm, overlap, ...) )
zperm <- 1 - ovperm
}))
} else {
zobs <- 1-out$OV
Zperm <- t(sapply(1:B, function(b) {
xperm <- sample( unlist( x ) )
xListperm <- list( x1 = xperm[1:N[1]], x2 = xperm[(N[1]+1):(sum(N))] )
zperm <- 1 - overlap( xListperm, ... )$OV
}))
}
## (sum( zperm >= obsz ) +1) / (length( zperm )+1) LIVIO
colnames(Zperm) <- gsub("\\.OV","",colnames(Zperm))
if (nrow(Zperm) > 1) {
ZOBS <- matrix( zobs, nrow(Zperm), ncol(Zperm), byrow = TRUE )
pval <- (apply( Zperm > ZOBS, 2, sum ) + 1)/ (nrow(Zperm)+1)
} else {
pval <- (sum(Zperm > zobs)+1) / (length(Zperm)+1)
}
if (return.distribution) {
return(list(Zobs = zobs, pval = pval, Zperm = Zperm))
} else {
return(list(Zobs = zobs, pval = pval))
}
}
@
install.packages("overlapping")
normPars <- c(10,2)
unifPars <- c(0,20)
n <- 30
set.seed(36)
x <- rnorm(n, normPars[1], normPars[2])
y <- runif(n, unifPars[1], unifPars[2])
LIST<-list(x,y)
OV <- overlap(LIST)
TTEST <- t.test(x,y, var.equal = TRUE)
TTESTUNEQUAL <- t.test(x,y, var.equal = FALSE)
Y <- stack( data.frame(y1=x,y2=y) )
myData <- data.frame( x = seq(0,20,by=.1) )
myData$y1 <- dnorm(myData$x, normPars[1], normPars[2] )
myData$y2 <- dunif(myData$x, unifPars[1], unifPars[2])
myData$h <- with(myData, ifelse( y1 < y2, y1, y2 ))
AREA <- integrate( min_normal_uniform, -Inf, Inf, normPars = normPars, unifPars = unifPars )
library(cowplot)
theme_set(theme_bw())
plot_grid(
ggplot(myData,aes(x,y1)) + geom_line() + geom_line(aes(x,y2)) +
geom_ribbon(aes(ymin=0,ymax=h), alpha = .5) + xlab("") + ylab("") +
scale_y_continuous( breaks = NULL ) + ggtitle("[A]"),
ggplot(Y, aes(values,fill=ind,color=ind)) + geom_density(alpha = .5) + xlab("") + theme(legend.title = element_blank()) + ylab("") +
scale_y_continuous( breaks = NULL ) + guides(fill="none",color="none")+ ggtitle("[B]"),
ncol = 2
)
library(ggplot2)
theme_set(theme_bw())
plot_grid(
ggplot(myData,aes(x,y1)) + geom_line() + geom_line(aes(x,y2)) +
geom_ribbon(aes(ymin=0,ymax=h), alpha = .5) + xlab("") + ylab("") +
scale_y_continuous( breaks = NULL ) + ggtitle("[A]"),
ggplot(Y, aes(values,fill=ind,color=ind)) + geom_density(alpha = .5) + xlab("") + theme(legend.title = element_blank()) + ylab("") +
scale_y_continuous( breaks = NULL ) + guides(fill="none",color="none")+ ggtitle("[B]"),
ncol = 2
)
library(readr)
EngTurk <- read_csv(paste0(datadir,"EngTurk.csv"))
main <- getwd()
main <- paste0(main,"/")
main
main <- getwd()
main <- paste0(main,"/")
datadir <- paste0(main,"/data/")
datadir <- paste0(main,"data/")
datadir
EngTurk <- read_csv(paste0(datadir,"EngTurk.csv"))
DATA <- subset( EngTurk, (item == "blue eyes")|(item == "poor children") )
low_frequency <- subset( DATA[,c("Participant","ReactionTime","item")], item == "poor children" )
colnames(low_frequency)[2] <- "low_frequency"
high_frequency <- subset( DATA[,c("Participant","ReactionTime","item")], item == "blue eyes" )
colnames(high_frequency)[2] <- "high_frequency"
Z <- merge( low_frequency[,-3], high_frequency[,-3], by = "Participant" )
head( DATA[,c("Participant","item","ReactionTime")] )
head( Z )
OV <- overlap( list( low_frequency = Z$low_frequency,
high_frequency= Z$high_frequency ) )
library(overlapping)
normPars <- c(10,2)
unifPars <- c(0,20)
n <- 30
set.seed(36)
x <- rnorm(n, normPars[1], normPars[2])
y <- runif(n, unifPars[1], unifPars[2])
LIST<-list(x,y)
OV <- overlap(LIST)
TTEST <- t.test(x,y, var.equal = TRUE)
TTESTUNEQUAL <- t.test(x,y, var.equal = FALSE)
Y <- stack( data.frame(y1=x,y2=y) )
myData <- data.frame( x = seq(0,20,by=.1) )
myData$y1 <- dnorm(myData$x, normPars[1], normPars[2] )
myData$y2 <- dunif(myData$x, unifPars[1], unifPars[2])
myData$h <- with(myData, ifelse( y1 < y2, y1, y2 ))
AREA <- integrate( min_normal_uniform, -Inf, Inf, normPars = normPars, unifPars = unifPars )
library(cowplot)
library(ggplot2)
theme_set(theme_bw())
plot_grid(
ggplot(myData,aes(x,y1)) + geom_line() + geom_line(aes(x,y2)) +
geom_ribbon(aes(ymin=0,ymax=h), alpha = .5) + xlab("") + ylab("") +
scale_y_continuous( breaks = NULL ) + ggtitle("[A]"),
ggplot(Y, aes(values,fill=ind,color=ind)) + geom_density(alpha = .5) + xlab("") + theme(legend.title = element_blank()) + ylab("") +
scale_y_continuous( breaks = NULL ) + guides(fill="none",color="none")+ ggtitle("[B]"),
ncol = 2
)
OV <- overlap( list( low_frequency = Z$low_frequency,
high_frequency= Z$high_frequency ) )
(eta <- OV$OV)
(zeta.obs <- 1-eta)
TEST <- perm.test( list( low_frequency = Z$low_frequency,
high_frequency= Z$high_frequency ), paired = TRUE,
return.distribution = TRUE, B = 3000 )
warnings()
TEST$Zobs
TEST$pval
?overlapping
??overlapping
library( devtools )
install_github( "masspastore/overlapping" )
TEST <- perm.test( list( low_frequency = Z$low_frequency,
high_frequency= Z$high_frequency ), paired = TRUE,
return.distribution = TRUE, B = 500 )
TEST$Zobs
TEST$pval
x1List <- list( x1 = low_frequency, x2 = high_frequency )
x1List[[1]] <- c(x1List[[1]], NA)
Y <- stack(data.frame(x1List))
ZPERM <- data.frame(zperm)
ggplot(Y, aes(values,fill=ind,color=ind)) +
geom_density(alpha = .5) +
theme(legend.title = element_blank()) +
xlab("Reaction Time (seconds)") +
ylab("") +
guides(fill="none",color="none") +
ggtitle("[A]")
View(x1List)
x1List <- list( x1 = low_frequency, x2 = high_frequency )
DATA
Z <- merge( low_frequency[,-3], high_frequency[,-3], by = "Participant" )
Z
ggplot(Z, aes(values,fill=ind,color=ind)) +
geom_density(alpha = .5) +
theme(legend.title = element_blank()) +
xlab("Reaction Time (seconds)") +
ylab("") +
guides(fill="none",color="none") +
ggtitle("[A]")
stack(Z)
W <- stack(Z)
View(W)
x1List <- list( x1 = low_frequency, x2 = high_frequency )
x1List[[1]] <- c(x1List[[1]], NA)
Y <- stack(data.frame(x1List))
View(Y)
low_frequency
W <- stack(data.frame(Z))
View(W)
?stack
head(Z)
W <- stack(data.frame(Z), select = c(low_frequency, high_frequency))
View(W)
cowplot::plot_grid(
ggplot(W, aes(values,fill=ind,color=ind)) +
geom_density(alpha = .5) +
theme(legend.title = element_blank()) +
xlab("Reaction Time (seconds)") +
ylab("") +
guides(fill="none",color="none") +
ggtitle("[A]"),
ggplot(ZPERM, aes(zperm)) +
geom_vline(xintercept = obsz, lty=2) +
geom_density() +
ggtitle("[B]") +
xlab(expression(paste(hat(zeta), " distribution"))) +
ylab(""),
ncol=2
)
ggplot(W, aes(values,fill=ind,color=ind)) +
geom_density(alpha = .5) +
theme(legend.title = element_blank()) +
xlab("Reaction Time (seconds)") +
ylab("") +
guides(fill="none",color="none") +
ggtitle("[A]")
??ggplot
TEST
View(TEST)
ZPERM <- data.frame(TEST$Zperm)
View(ZPERM)
TEST$Zperm
as.vector(TEST$Zperm)
as.dataframe(as.vector(TEST$Zperm))
dataframe(as.vector(TEST$Zperm))
data.frame(as.vector(TEST$Zperm))
ZPERM <- data.frame(as.vector(TEST$Zperm))
Zperm <- as.vector(TEST$Zperm)
ZPERM <- data.frame(TEST$Zperm)
View(ZPERM)
View(ZPERM)
as.vector(TEST$Zperm)
Zperm
data.frame(Zperm)
ZPERM <- data.frame(Zperm)
View(ZPERM)
theme_set(theme_bw())
cowplot::plot_grid(
ggplot(W, aes(values,fill=ind,color=ind)) +
geom_density(alpha = .5) +
theme(legend.title = element_blank()) +
xlab("Reaction Time (seconds)") +
ylab("") +
guides(fill="none",color="none") +
ggtitle("[A]"),
ggplot(ZPERM, aes(Zperm)) +
geom_vline(xintercept = obsz, lty=2) +
geom_density() +
ggtitle("[B]") +
xlab(expression(paste(hat(zeta), " distribution"))) +
ylab(""),
ncol=2
)
Zobs <- TEST$Zobs
Zpval <- TEST$pval
cowplot::plot_grid(
ggplot(W, aes(values,fill=ind,color=ind)) +
geom_density(alpha = .5) +
theme(legend.title = element_blank()) +
xlab("Reaction Time (seconds)") +
ylab("") +
guides(fill="none",color="none") +
ggtitle("[A]"),
ggplot(ZPERM, aes(Zperm)) +
geom_vline(xintercept = Zobs, lty=2) +
geom_density() +
ggtitle("[B]") +
xlab(expression(paste(hat(zeta), " distribution"))) +
ylab(""),
ncol=2
)
Zobs
View(Z)
MNX  <- apply(Z[,2:3], mean)
MNX  <- apply(Z[,2:3],2, mean)
MNX
MNX  <- apply(Z[,2:3],2, mean)
MDX  <- apply(Z[,2:3],2, median)
SDX  <- apply(Z[,2:3],2, var)
SKX  <- apply(Z[,2:3],2, skewness)
KRTX <- apply(Z[,2:3],2, kurtosis)
stats <- data.frame(
c("Mean", "Median", "Variance", "Skewness", "Kurtosis"),
c(MNX$x1, MDX$x1, SDX$x1, SKX$x1, KRTX$x1),
c(MNX$x2, MDX$x2, SDX$x2, SKX$x2, KRTX$x2)
)
MNX
MNX$low_frequency
MNX[1]
MDX
MDX[1]
stats <- data.frame(
c("Mean", "Median", "Variance", "Skewness", "Kurtosis"),
c(MNX[1], MDX[1], SDX[1], SKX[1], KRTX[1]),
c(MNX[2], MDX[2], SDX[2], SKX[2], KRTX[2])
)
colnames(stats) <- c("", "Low frequency", "High frequency")
xt <- xtable(
stats,
caption = "Descriptive statistics for low and high frequency words",
label = "tab:desc_stats"
)
library(moments)
library(xtable)
MNX  <- apply(Z[,2:3],2, mean)
MDX  <- apply(Z[,2:3],2, median)
SDX  <- apply(Z[,2:3],2, var)
SKX  <- apply(Z[,2:3],2, skewness)
KRTX <- apply(Z[,2:3],2, kurtosis)
stats <- data.frame(
c("Mean", "Median", "Variance", "Skewness", "Kurtosis"),
c(MNX[1], MDX[1], SDX[1], SKX[1], KRTX[1]),
c(MNX[2], MDX[2], SDX[2], SKX[2], KRTX[2])
)
colnames(stats) <- c("", "Low frequency", "High frequency")
xt <- xtable(
stats,
caption = "Descriptive statistics for low and high frequency words",
label = "tab:desc_stats"
)
print(
xt,
include.rownames = FALSE,
booktabs = TRUE,
floating = TRUE,
caption.placement = "bottom"
)
Zobs
zeta.obs
TEX <- t.test( Z$low_frequency, Z$high_frequency, paired = TRUE )
Z
length(Z$low_frequency)
SKX[1]
MNX[2]
TEST[[1]]
TEST[[-3]]
Zobs
TEST
TEST[[1]]
T1<-TEST[[1]]
T1
View(TEST)
TEST[-1]
TEST[-3]
ZPERM
( ZPERM )
length( ZPERM )+1
length( ZPERM )
??length
?length
length( ZPERM[1]
length( ZPERM[1] )
View(ZPERM)
length( ZPERM$Zperm)
24/3001
